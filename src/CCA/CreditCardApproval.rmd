---
title: "UADE - Maestria TIC - Ciencia de Datos - Modelo de predicción para aprobación de Tarjetas de Crédito"
author: "Marcelo Capozzi (LU: 1119183) - Nicolas Gladkoff (LU: 1085075)"
date: "Abril 2020"
output:
  html_notebook: default
  html_document:
    df_print: paged
  pdf_document: default
---

#### GitHub:
https://github.com/ngladkoff/ds-credit-card-approval

#### DataSource:
https://www.kaggle.com/rikdifos/credit-card-approval-prediction


# Objetivo
El presente trabajo busca evaluar si es posible predecir si en base a los datos de una solicitud de tarjeta de crédito tiene alta probabilidad de quedar impaga. 

Para este modelo de predicción se analizarán los datos de la información histórica del comportamiento de pago de los clientes pasados y actuales de la entidad.

La decisión actualmente la toma el Analista de Créditos en base a su experiencia, se busca brindarle una herramienta adicional que facilite su trabajo o sirva de justificación de sus decisiones.

Queremos mejorar el proceso de selección, reduciendo un 15% la incobrabilidad.   


# Datos

La entidad crediticia nos proporcionó los datos históricos que tienen disponibles, datos que deberán ser analizados para evaluar su calidad y si son suficientes para ayudarnos a resolver el problema.

Se nos proporcionó 2 datasets: 

- application_record.csv: que contiene los datos de las solicitudes de tarjetas de crédito

- credit_record.csv: que contiene la información histórica del comportamiento de pagos


## Diccionario de datos

Descripción de los datasets

***application_record***

| Feature name | Explanation | Remarks | 
|---|---|---|
| ID | Cliente number ||
| CODE_GENDER| gender ||
| FLAGOWNCAR | Is there a car ||
| FLAGOWNREALTY | Is there a property ||
| CNT_CHILDREN | Number of children || 
| AMTINCOMETOTAL | Annual income ||
| NAMEINCOMETYPE |	Income category	||
| NAMEEDUCATIONTYPE | education level ||
| NAMEFAMILYSTATUS | Marital status ||
| NAMEHOUSINGTYPE | Way of living ||
| DAYS_BIRTH | birthday ||
| DAYS_EMPLOYED | Start date ||
| FLAG_MOBIL | Is there a mobile phone ||
| FLAGWORKPHONE | Is there a work phone	||
| FLAG_PHONE | Is there a phone ||
| FLAG_EMAIL | Is there an email	||
| OCCUPATION_TYPE | Occupation ||
| CNTFAMMEMBERS | Family size	||

***credit_record***

| Feature name | Explanation | Remarks | 
|---|---|---|
| ID | client number ||
| MONTHS_BALANCE | record month | The month of the extracted data is the starting point, backwards, 0 is the current month, -1 is the previous month, and so on
| STATUS | status | 0: 1-29 days past due 1: 30-59 days past due 2: 60-89 days overdue 3: 90-119 days overdue 4: 120-149 days overdue 5: Overdue or bad debts, write-offs for more than 150 days C: paid off that month X: No loan for the month

## Configuración de ambiente y carga de los datos

Seteamos las librerías a utilizar y cargamos los datasets en el ambiente de trabajo.

```{r, message=FALSE}
##################
# Load libraries #
##################
library(ggplot2)
library(dplyr)
library(sqldf)
library(corrplot)
library(Information)

```

Si los datasets no están en el directorio de trabajo los descargamos:

```{r}
######################
# Download datafiles #
######################

# Set the data directory 
# It will be a subdirectory 'data/' of the current directory
maindir <- getwd()
datadir <- paste(maindir, "data", sep="/")

applRecordURL <- "https://raw.githubusercontent.com/ngladkoff/ds-credit-card-approval/master/data/application_record.csv"
credRecordURL <- "https://raw.githubusercontent.com/ngladkoff/ds-credit-card-approval/master/data/credit_record.csv"

applRecordFile <- paste(datadir, "applRecord.csv", sep="/")
credRecordFile <- paste(datadir, "credRecord.csv", sep="/")

if (!dir.exists(datadir)) {
    print(paste("Creating data directory ", datadir))
    dir.create(datadir)
}

if (!file.exists(applRecordFile)) {
    print("Downloading Application Records")
    download.file(applRecordURL, applRecordFile, method="auto")
} else {
    print(paste("Data file", applRecordFile, "already exists"))
}

if (!file.exists(credRecordFile)) {
    print("Downloading Application Records")
    download.file(credRecordURL, credRecordFile, method="auto")
} else {
    print(paste("Data file", credRecordFile, "already exists"))
}

```

```{r}
#######################
# Load the dataframes #
#######################

dfApplications <- read.csv(applRecordFile)
dfCredits <- read.csv(credRecordFile)

```


# Análisis Exploratorio de Datos

## 1 - Exámen inicial de los datos

### 1.1 - Applications

#### 1.1.1 - Estructura

```{r}
str(dfApplications)
```

En la estructura observamos el tipo de cada variable, observando algunas que necesitan ser convertidas en categóricas:

- FLAG_MOBIL
- FLAG_WORK_PHONE
- FLAG_PHONE
- FLAG_EMAIL

Se observa también algunas variables categóricas con muchas categorías, algo a tener en cuenta pues el tipo de problema puede resolverse utilizando una regresión logística, y este tipo de modelo pierde capacidad de predicción ante este tipo de variables.

Por último, nos llama la atención la variable DAYS_EMPLOYED que tiene valores negativos y positivos, algunos muy grandes (en el rango de los 1000 años)


#### 1.1.2 - Conversión variables categóricas

```{r}
dfApplications$FLAG_MOBIL <- factor(dfApplications$FLAG_MOBIL, ordered=FALSE)
dfApplications$FLAG_WORK_PHONE <- factor(dfApplications$FLAG_WORK_PHONE, ordered=FALSE)
dfApplications$FLAG_PHONE <- factor(dfApplications$FLAG_PHONE, ordered=FALSE)
dfApplications$FLAG_EMAIL <- factor(dfApplications$FLAG_EMAIL, ordered=FALSE)

```

#### 1.1.3 - Summary
```{r}
summary(dfApplications)
```

Se vuelve a observar alguna anormalidad en la variable DAYS_EMPLOYED que deberá ser analizada.

Se observa que la variable FLAG_MOBIL solo tiene una categoría, por lo que ya se puede descartar por no aportar valor al modelo.

La variable OCCUPATION_TYPE además de tener muchas categorías, como ya se había notado anteriormente, parece tener datos incompletos. Deberá ser analizado.

Respecto a la cantidad de hijos y el ingreso total vamos a tener que evaluar la distribución, los máximos y mínimos están muy lejos del promedio y la mediana.

#### 1.1.4 - Busqueda de IDs duplicados

Para asegurarnos que ambos datasets se puedan juntar una vez procesados debemos asegurarnos no tener IDs duplicados en el dataset de Applications.

```{r}
dfAppIds <- data.frame(table(dfApplications$ID))
cUniAppIds <- dim(dfApplications[unique(dfApplications$ID),])[1]
cDupAppIds <- dim(dfApplications[duplicated(dfApplications$ID),])[1]
cDupAppRecord <- dim(dfApplications[duplicated(dfApplications),])[1]
dfDupAppIds <- dfApplications[duplicated(dfApplications$ID),]
cAppIds <- dim(dfApplications)[1]

print(paste("IDs unicos:", cUniAppIds))
print(paste("IDs duplicados:", cDupAppIds))
print(paste("Records duplicados: ", cDupAppRecord))
print(paste("Total:", cAppIds))
print(paste("Duplicados: %", (round((cDupAppIds*100/cAppIds), digits=2))))

```

Observamos que tenemos 47 IDs duplicados, pero "Records duplicados" nos está marcando que contienen distintos datos, no es una misma solicitud cargada 2 veces sino que son 2 solicitudes con el mismo ID.

Por el bajo porcentaje que representan se decide eliminar del análisis estos registros duplicados.

```{r}
dfDupAppIds2 <- data.frame(dfDupAppIds$ID)
dfDupIds <- sqldf("SELECT distinct ID FROM dfApplications WHERE ID in dfDupAppIds2")
dfApplicationsCleaned <- sqldf("SELECT * FROM dfApplications WHERE ID NOT in dfDupAppIds2")
cNewTotal <- dim(dfApplicationsCleaned)[1]
print(paste("Cantidad Anterior - Cantidad Nueva: ",cAppIds - cNewTotal))
```

Verificamos que la cantidad nueva tiene 94 registros menos (47 duplicados x 2).


### 1.2 - Credits

#### 1.2.1 - Estructura

```{r}
str(dfCredits)
```

Aparentemente cada ID de solicitud se crean varios registros, uno por cada mes, con el estado de la deuda en dicho mes.

Se imprimen los primeros y ultimos registros para validar:
```{r}
head(dfCredits)
tail(dfCredits)
```

Como conslusión, vamos a necesitar reducir estos datos a un solo registro por ID de aplicación para poder fittiar nuestro modelo.


#### 1.2.2 - Summary

```{r}
summary(dfCredits)
```

No se observan números fuera de rango dentro de la variable MONTHS_BALANCE.

Para analizar correctamente la variable STATUS vamos a necesitar reducir los registros a uno por ID previamente.


## 2 - Reducción dataset Credits

### 2.1 - Identificar IDs únicos
```{r}
dfCredIds <- data.frame(table(dfCredits$ID))
```


#### 2.1.1 - Estructura
```{r}
str(dfCredIds)
```

El dataset Credits cuenta con 45985 IDs únicos, es decir que del dataset de Applications de poco más de 438000 registros solo tenemos información de algunos.

#### 2.1.2 - Summary
```{r}
summary(dfCredIds)
```


### 2.2 - Reducir registros

Se decidió que vamos a tomar el estado del último més del que tenemos información. 

Para esto recuperamos primero cual es ese último mes:
```{r}

dfCreditsLastMonth <- sqldf("SELECT ID, MAX(MONTHS_BALANCE) as LAST FROM dfCredits GROUP BY ID order by LAST")
str(dfCreditsLastMonth)

```

Verificamos que la cantidad de registros coincide con el análisis de IDs únicos. 

Continuamos agregando el estádo del crédito en ese último mes.
```{r}
dfCreditsReduced <- sqldf("SELECT t1.ID, t1.LAST, t2.STATUS FROM dfCreditsLastMonth t1 JOIN dfCredits t2 ON t1.ID = t2.ID and t1.LAST = t2.MONTHS_BALANCE")
summary(dfCreditsReduced)
```

Definimos nuestra variable objetivo: Approve. Para esto teniendo en cuenta el STATUS en el último mes que se tiene registro, asumimos que si no quedó con deuda (estados C, X y 0) debería ser aprobada esa solicitud y si quedó en alguno de los otros estados entonces no.
```{r}
dfCreditsReduced$Approve <- ifelse(dfCreditsReduced$STATUS == 'C' | dfCreditsReduced$STATUS == 'X' | dfCreditsReduced$STATUS == '0', 1, 0)
dfCreditsReduced$Approve <- factor(dfCreditsReduced$Approve, ordered = FALSE)
summary(dfCreditsReduced)
```

Se observa que la cantidad de créditos "malos" es de aproximadamente el 1%, que no es un porcentaje razonable de incobrabilidad, que según lo que hemos investigado suele ser lijeramente superior al 3%. 

Se debería consultar a negocio si pueden ser correctos estos valores, podría suceder que tuviera una cartera de muy buena calidad crediticia.

A los fines del ejercicio, y para que no quede una distribución muy desbalanceada se decide probar interpretando los créditos con deuda en los últimos 30 días (Status=0) también como incobrables. 

Se redefine la variable Approve:
```{r}
dfCreditsReduced$Approve <- ifelse(dfCreditsReduced$STATUS == 'C' | dfCreditsReduced$STATUS == 'X', 1, 0)
dfCreditsReduced$Approve <- factor(dfCreditsReduced$Approve, ordered = FALSE)
summary(dfCreditsReduced)

```

Con esta nueva definición, tenemos un 31% de créditos "malos", que vamos a utilizar para entrenar el modelo.


## 3 - Unificar los datasets

### 3.1 - Unificar
```{r}
dfCreditCard <- merge(dfApplicationsCleaned, dfCreditsReduced, by="ID")
```

### 3.2 - Estructura
```{r}
str(dfCreditCard)
```

### 3.3 - Summary
```{r}
summary(dfCreditCard)
```


### 3.4 - Conclusiones de la unificación

Luego de unir ambos datasets observamos que la cantidad de registros de clientes que poseen información histórica ha disminuido. 

Esto se debe a que no todas las solicitudes de tarjeta de crédito tienen asociado un historial crediticio registrado. 

Para los fines de este análisis, aceptaremos cómo válida esta reducción en el set de datos.
 
```{r}
print(paste("Registros en el historial:", dim(dfCreditsReduced)[1]))
print(paste("Solicitudes de tarjetas de crédito con registros en el historial:", dim(dfCreditCard)[1]))
```

## 4 - Análisis de variables sobre dataset unificado

 ***ToDo*** 1ro analizar la variables una a una y 2do analizar si hay relación entre la variable candidata a predictora y la variable objetivo.
 
 
### 4.1 Análisis de variables númericas

#### 4.1.1. Variable: CNT_CHILDREN

##### CNT_CHILDREN

En relación a la variable *CNT_CHILDREN* observaremos la distribución de la cantidad total de hijos en cada barra del siguiente gráfico:

```{r}
ggplot(dfCreditCard) + 
  geom_histogram(
    aes(x=CNT_CHILDREN), 
    fill="steel blue",
    col= "yellow",
    alpha= .6,
    binwidth = 1) + 
  labs(title="Histograma: Cantidad de hijos en Solicitudes", x="Cantidad Hijos", y="Cantidad Solicitudes")
```

Se observa una marcada concentración respeto de la cantidad de hijos cuando dicho valor es menor o igual a 2.

```{r}
summary(dfCreditCard$CNT_CHILDREN)
```

Se observa en el summary la presencia de valores cercanos a 20, pero como puede observarse en el gráfico anterior son outliers, no hay concentración en esas cantidades.

##### CNT_CHILDREN vs APPROVE

Vamos a utilizar el gráfico BoxPlot para tratar de entender como se relacionan la variable CNT_CHILDREN y nuestra variable Objetivo.

```{r}
ggplot(dfCreditCard) + 
  geom_boxplot(aes(x=Approve, y=CNT_CHILDREN), outlier.color = "red", col="yellow", fill="steel blue", alpha=0.6) +
  labs(title="BoxPlot: Calidad Crediticia según Cantidad de Hijos", x="Credito Malo (0) o Bueno (1)", y="Cantidad de Hijos")
```

Observamos que la cantidad de casos aprobados en comparación de los que no, se mantienen en valores similares. Esto sucede hasta aproximadamente los 5 hijos. Luego de ese valor, aumenta la cantidad de casos con falta de pago en su historial crediticio.

Representando los datos de una manera diferente, podemos observar que la inferencia realizada anteriormente es consistente.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=CNT_CHILDREN, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según cantidad de hijos", x="Cantidad de Hijos", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```


Los casos donde la cantidad de hijos sea mayor a 5 supone una falta de pago de acuerdo al criterio mencionado previamente.

Debemos mencionar que esta suposición tiene lógica desde el punto de vista del negocio, por tratarse de outliers, poco representados, podríamos estar sesgando el resultado. Debemos ser cuidadosos, pero podría ser un posible predictor.


#### 4.1.2. Variable: AMT_INCOME_TOTAL

##### AMT_INCOME_TOTAL

En relación a la variable *AMT_INCOME_TOTAL* observaremos su distribuciónen el siguiente gráfico:

```{r}
ggplot(dfCreditCard) + 
  geom_histogram(
    aes(x=AMT_INCOME_TOTAL), 
    fill="steel blue",
    col= "yellow",
    alpha= .6, bins=10) + 
  labs(title="Histograma: Ingresos", x="Ingreso anual (u$d)", y="Cantidad Solicitudes")
```

Se observa una marcada concentración de solicitudes en un rango medio de ingresos anuales. si bien se observa la presencia de algunas solicitudes con ingresos muy superiores.

```{r}
summary(dfCreditCard$AMT_INCOME_TOTAL)
```

Dentro del rango de los 120000 y los 225000 dolares anuales de ingreso se concentra el 50% de las solicitudes de tarjeta de crédito. Vemos la presencia de valores muy inferiores y muy superiores.


##### AMT_INCOME_TOTAL vs APPROVE

Vamos a utilizar el gráfico BoxPlot para tratar de entender como se relacionan la variable AMT_INCOME_TOTAL y nuestra variable Objetivo.

```{r}
ggplot(dfCreditCard) + 
  geom_boxplot(aes(x=Approve, y=AMT_INCOME_TOTAL), outlier.color = "red", col="yellow", fill="steel blue", alpha=0.6) +
  labs(title="BoxPlot: Calidad Crediticia según Ingresos Anuales", x="Credito Malo (0) o Bueno (1)", y="Ingresos (u$d)")
```

No observamos diferencias significativas en este gráfico. Vamos a intentar representarlo de manera diferente.

```{r}
ggplot(dfCreditCard) +
  geom_histogram(aes(x=AMT_INCOME_TOTAL, fill=Approve), position="fill", alpha=.5, bins=10) +
  labs(title="Creditos Buenos vs Creditos Malos según Ingresos Anuales", x="Ingresos (u$d)", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```

El comportamiento que observamos en el gráfico para las solicitudes con mayores ingresos parece ser ruido por la baja cantidad de datos con los que esa categoría está representada en la muestra. 

No parece existir una marcada relación entre los ingresos y la calidad crediticia.


#### 4.1.3. Variable: DAYS_BIRTH

##### DAYS_BIRTH

```{r}
summary(dfCreditCard$DAYS_BIRTH)
```

Como se observa, está expresado en días y en negativo, vamos a convertirlo a una escala a la que estamos más acostumbrados a ver, que es expresar la edad en años.

```{r}
dfCreditCard$AGE <- (dfCreditCard$DAYS_BIRTH * -1) %/% 365 
summary(dfCreditCard$AGE)
```

Expresado de esta manera podemos observar que los valores son razonables. 

Observaremos la distribución en el siguiente gráfico:

```{r}
ggplot(dfCreditCard) + 
  geom_histogram(
    aes(x=AGE), 
    fill="steel blue",
    col= "yellow",
    alpha= .6, bins=10) + 
  labs(title="Histograma: Edades", x="Años", y="Cantidad Solicitudes")
```

Observamos una distribución con cierta semejanza a una campana de Gauss (Normal). 
 

##### AGE vs APPROVE

Vamos a utilizar el gráfico BoxPlot para tratar de entender como se relacionan la variable AGE y nuestra variable Objetivo.

```{r}
ggplot(dfCreditCard) + 
  geom_boxplot(aes(x=Approve, y=AGE), outlier.color = "red", col="yellow", fill="steel blue", alpha=0.6) +
  labs(title="BoxPlot: Calidad Crediticia según Edad", x="Credito Malo (0) o Bueno (1)", y="Años")
```

No observamos diferencias significativas en este gráfico. Vamos a intentar representarlo de manera diferente.

```{r}
ggplot(dfCreditCard) +
  geom_histogram(aes(x=AGE, fill=Approve), position="fill", alpha=.5, binwidth = 10) +
  labs(title="Creditos Buenos vs Creditos Malos según Edades", x="Años", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```

Parece existir una ligera tendencia a que los créditos mejoren a medida que aumenta la edad. Podría ser un posible predictor.


#### 4.1.4. Variable: DAYS_EMPLOYED

##### DAYS_EMPLOYED

```{r}
summary(dfCreditCard$DAYS_EMPLOYED)
```

Como se observa, está expresado en días y en negativo, vamos a convertirlo a una escala a la que estamos más acostumbrados a ver, que es expresarlo en años. Se observan también valores positivos, que se les va a tener que dar un tratamiento.

```{r}
dfCreditCard$YEARS_EMPLOYED <- (dfCreditCard$DAYS_EMPLOYED * -1) %/% 365 
summary(dfCreditCard$YEARS_EMPLOYED)
```

Expresado de esta manera podemos observar edades negativas. 

Buscamos estos valores:

```{r}
dfNegatives <- filter(dfCreditCard, YEARS_EMPLOYED < 0)
str(dfNegatives)
```

Observamos un número importante de registros con este dato inválido. Como no podemos consultar a negocio que significan esos valores suponemos que "antigüedad laboral desconocida", los vamos a reemplazar por la mediana que es más representativa de la antigüedad que el promedio, justamente por la presencia de estos valores.

```{r}
dfCreditCard$YEARS_EMPLOYED[dfCreditCard$YEARS_EMPLOYED < 0] <- median(dfCreditCard$YEARS_EMPLOYED)

summary(dfCreditCard$YEARS_EMPLOYED)
```

Ahora los valores parecen razonables.

Observaremos la distribución en el siguiente gráfico:

```{r}
ggplot(dfCreditCard) + 
  geom_histogram(
    aes(x=YEARS_EMPLOYED), 
    fill="steel blue",
    col= "yellow",
    alpha= .6, bins=10) + 
  labs(title="Histograma: Antigüedad Laboral", x="Años", y="Cantidad Solicitudes")
```

##### YEARS_EMPLOYED vs APPROVE

Vamos a utilizar el gráfico BoxPlot para tratar de entender como se relacionan la variable YEARS_EMPLOYED y nuestra variable Objetivo.

```{r}
ggplot(dfCreditCard) + 
  geom_boxplot(aes(x=Approve, y=YEARS_EMPLOYED), outlier.color = "red", col="yellow", fill="steel blue", alpha=0.6) +
  labs(title="BoxPlot: Calidad Crediticia según Antigüedad Laboral", x="Credito Malo (0) o Bueno (1)", y="Años")
```

Se observan algunas pequeñas diferencias en este gráfico. Vamos a intentar representarlo de manera diferente.

```{r}
ggplot(dfCreditCard) +
  geom_histogram(aes(x=YEARS_EMPLOYED, fill=Approve), position="fill", alpha=.5, binwidth = 10) +
  labs(title="Creditos Buenos vs Creditos Malos según Antigüedad Laboral", x="Años", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```

La pequeña diferencia notada en el gráfico anterior desaparece en este gráfico, donde no parece haber una clara relación entre la calidad crediticia y la antigüedad laboral.


#### 4.1.5. Variable: CNT_FAM_MEMBERS

##### CNT_FAM_MEMBERS

En relación a la variable *CNT_FAM_MEMBERS* observaremos la distribución de la cantidad total de integrantes de la familia, en cada barra del siguiente gráfico:

```{r}
ggplot(dfCreditCard) + 
  geom_histogram(
    aes(x=CNT_FAM_MEMBERS), 
    fill="steel blue",
    col= "yellow",
    alpha= .6,
    binwidth = 1) + 
  labs(title="Histograma: Cantidad de Integrantes Familiares en Solicitudes", x="Cantidad Integrantes", y="Cantidad Solicitudes")
```

Como era de esperarse se observa una distribución similar a la cantidad de hijos, son variables claramente relacionadas.

##### CNT_FAM_MEMBERS vs APPROVE

Es de esperarse que la relación entre estas dos variables sea similar a lo ya evaluado con cantidad de hijos, se utiliza el gráfico de barras para convalidarlo.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=CNT_FAM_MEMBERS, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según cantidad de miembros familiares", x="Cantidad de integrantes", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```


Para su elección o no como predictor deberíamos evaluar si vamos o no a incluir Cantidad de Hijos, porque solo una de las dos variables sería el predictor por estar correlacionadas entre ellas.

#### 4.1.6. Variable: LAST

Es una variable que creamos nosotros para expresar el último período del cual tenemos datos, sirvió de variable intermedia para calcular la situación crediticia. No sirve como predictor.


### 4.2 Correlación de variables numéricas

Mediante un gráfico de correlación de las variables numéricas vamos a analizar como se relacionan entre ellas.

```{r}
dfcor <- select_if(dfCreditCard, is.numeric)
dfcor <- select(dfcor, -ID, -LAST, -DAYS_EMPLOYED, -DAYS_BIRTH)
cm <- cor(dfcor)
corrplot(cm, method = "number", type = "upper")
```


Observamos en el gráfico que Cantidad de Hijos y Cantidad de Miembros Familiares están muy relaionados, nos parece más amplio el concepto de Miembros Familiares para seleccionarlo como predictor.

No observamos correlaciones significativas entre el resto de las variables.


### 4.3 Análisis de variables categóricas


























---

### Sacado de mas arriba

```{r}
ggplot(dfCreditCard) +
    geom_point(aes(x=Approve, y=CNT_CHILDREN), color="steel blue")
```


En base al análisis de los datos, podríamos inferir que cuando la cantidad de hijos es mayor a 5, el porcentaje de pagos disminuye, por ende la cantidad de desaprobaciones aumenta.

Por fuera de esa concentración detectamos valores bien marcados que deberemos determinar cómo tratarlos.

Podemos confirmar que el valor general observado anteriormente mantiene el nivel de concentración para la cantidad de hijos en relación al pago dentro su historial crediticio. 


***ToDo*** definir que hacer con los outliers. si se agregan reemplazando el valor por el promedio o se descartan.









Observaremos para el análisis en cuestión la correlación de los valores númericos del dataset unificado.

En el gráfico de correlación podemos identificar y destacar un coeficiente de correlación positiva entre la *CNT_CHILDREN* y *CNT_FAM_MEMBERS*. Esta es una relación presente entre la cantidad de hijos y la cantidad de miembros de una familia.

También hemos observado el coeficiente de correlación negativo hayado en la relación entre *DAYS_BIRTH* y *DAYS_EMPLOYED*. 

***ToDo*** mejorar la justificación desde el lado del negocio

***ToDo*** Estas variables numéricas no fueron limpiadas todavía, no podemos hacer todavía la correlación porque tiene valores inválidos. ***Esto hay que hacerlo mas abajo***

```{r}
dfcor <- select_if(dfCreditCard, is.numeric)
dfcor <- select(dfcor, -ID)
cm <- cor(dfcor)
corrplot(cm, method = "number", type = "upper")
```






---
# DRAFT - PAPELES DE TRABAJO

```{r}

#ggplot(dfCreditCard) +
#    geom_point(aes(x=Approve, y=CNT_FAM_MEMBERS), color="steel blue")

#barplot(table(dfCreditCard$STATUS))

#barplot(table(dfCreditCard$OCCUPATION_TYPE))

##### ☺grafico 19 cat barras horizontales
###### mapa de calor / covid

```


```{r}
#library(purrr)
#library(tidyr)
#library(ggplot2)

#mtcars %>%
#  keep(is.numeric) %>% 
#  gather() %>% 
#  ggplot(aes(value)) +
#    facet_wrap(~ key, scales = "free") +
#    geom_histogram()

```

## Evaluo IDs duplicados en Applications
```{r}
dfAppIds <- data.frame(table(dfApplications$ID))
str(dfAppIds)
summary(dfAppIds)

```

## Analisis de duplicados
```{r}
cUniAppIds <- dim(dfApplications[unique(dfApplications$ID),])[1]
cDupAppIds <- dim(dfApplications[duplicated(dfApplications$ID),])[1]
cDupAppRecord <- dim(dfApplications[duplicated(dfApplications),])[1]
dfDupAppIds <- dfApplications[duplicated(dfApplications$ID),]
cAppIds <- dim(dfApplications)[1]

print(paste("IDs unicos:", cUniAppIds))
print(paste("IDs duplicados:", cDupAppIds))
print(paste("Records duplicados: ", cDupAppRecord))
print(paste("Total:", cAppIds))
print(paste("Duplicados: %", (round((cDupAppIds*100/cAppIds), digits=2))))

```

## Hicimos una limpieza del 1er dataset
```{r}
dfDupAppIds2 <- data.frame(dfDupAppIds$ID)
dfDupIds <- sqldf("SELECT distinct ID FROM dfApplications WHERE ID in dfDupAppIds2")
print(dfDupIds)

dfAppCleaned <- sqldf("SELECT * FROM dfApplications WHERE ID NOT in dfDupAppIds2")
cNewTotal <- dim(dfAppCleaned)[1]
print(cAppIds - cNewTotal)
```

## Obtener predictor desde Creditos

```{r}

dfCredIdMonth <- sqldf("SELECT ID, MAX(MONTHS_BALANCE) as LAST FROM dfCredit GROUP BY ID order by LAST")
summary(dfCredIdMonth)

```

```{r}
dfCreditCleaned <- sqldf("SELECT t1.ID, t1.LAST, t2.STATUS FROM dfCredIdMonth t1 JOIN dfCredit t2 ON t1.ID = t2.ID and t1.LAST = t2.MONTHS_BALANCE")
summary(dfCreditCleaned)
```

```{r}
dfCreditCleaned$STATUS <- ifelse(dfCreditCleaned$STATUS == 'C' | dfCreditCleaned$STATUS == 'X', 1, 0)
#dfCreditCleaned$STATUS <- factor(dfCreditCleaned$STATUS, ordered=FALSE)
```

```{r}
summary(dfCreditCleaned)
```


```{r}

#dfCreditCard <- merge(dfApplications, dfCreditCleaned, by="ID")
dfCreditCard <- sqldf("SELECT t1.ID, t1.CODE_GENDER, t1.FLAG_OWN_CAR, t1.FLAG_OWN_REALTY, t1.CNT_CHILDREN, t1.AMT_INCOME_TOTAL, t1.NAME_INCOME_TYPE, t1.NAME_EDUCATION_TYPE, t1.NAME_FAMILY_STATUS, t1.NAME_HOUSING_TYPE, t1.DAYS_BIRTH, t1.DAYS_EMPLOYED, t1.FLAG_MOBIL, t1.FLAG_PHONE, t1.FLAG_WORK_PHONE, t1.FLAG_EMAIL, t1.OCCUPATION_TYPE, t1.CNT_FAM_MEMBERS, t2.LAST, t2.STATUS FROM dfApplications t1 JOIN dfCreditCleaned t2 ON t1.ID = t2.ID")

```


```{r}
summary(dfCreditCard)

dim(dfCreditCard)[1]
```

```{r}
str(dfCreditCard)
```

```{r}
dfSelect <- select(dfCreditCard, OCCUPATION_TYPE, STATUS)
plot(dfSelect)

dfSelect <- select(dfCreditCard, NAME_EDUCATION_TYPE, STATUS)
plot(dfSelect)

dfSelect <- select(dfCreditCard, DAYS_EMPLOYED, STATUS)
plot(dfSelect)

#ggplot(dfCreditCard) +
#    geom_boxplot(aes(x=OCCUPATION_TYPE, y=STATUS))

```

```{r}
#mydata <- read.csv("https://stats.idre.ucla.edu/stat/data/binary.csv")
#summary(mydata)
IV <- create_infotables(data=dfCreditCard, y="STATUS", bins=10, parallel=FALSE)
```


```{r}

dfcor <- select_if(dfCreditCard, is.numeric)
dfcor <- select(dfcor, -ID)
cm <- cor(dfcor)
corrplot(cm)

```


```{r}
ggplot(dfCreditCard) +
    geom_boxplot(aes(x=DAYS_BIRTH, y=CNT_FAM_MEMBERS))
```


## Merge Data (antes de mergear la data hay que limpiarla! o hacer un pivot de los meses? los meses llegan hasta -60 -> sacar conclusiones y ajustar a una columna? -> ejemplo: antigúedad del prestamo o credit record)
```{r}
dfCreditCard <- merge(dfApplications, dfCredit, by="ID")
```

