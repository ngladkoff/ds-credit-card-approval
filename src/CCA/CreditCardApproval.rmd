---
title: "UADE - Maestria TIC - Ciencia de Datos - Modelo de predicción para aprobación de Tarjetas de Crédito"
author: "Marcelo Capozzi (LU: 1119183) - Nicolas Gladkoff (LU: 1085075)"
date: "Abril 2020"
output:
  html_notebook: default
  html_document:
    df_print: paged
  pdf_document: default
---

#### GitHub:
https://github.com/ngladkoff/ds-credit-card-approval

#### DataSource:
https://www.kaggle.com/rikdifos/credit-card-approval-prediction


# Introducción
El presente trabajo busca evaluar si es posible predecir si en base a los datos de una solicitud de tarjeta de crédito tiene alta probabilidad de quedar impaga. 

Para este modelo de predicción se analizarán los datos de la información histórica del comportamiento de pago de los clientes pasados y actuales de la entidad.

La decisión actualmente la toma el Analista de Créditos en base a su experiencia, se busca brindarle una herramienta adicional que facilite su trabajo o sirva de justificación de sus decisiones.

# Objetivo
Queremos mejorar el proceso de selección, reduciendo un 10% la incobrabilidad. 

Para esto crearemos una variable Objetivo *Approve* en la que 1 representa un crédito que debería ser aprobado y 0 uno que no debería ser aprobado. Se completará esta variable en los datasets analizando el historial crediticio que tuvieron las solicitudes. 


# Datos

La entidad crediticia nos proporcionó los datos históricos que tienen disponibles, datos que deberán ser analizados para evaluar su calidad y si son suficientes para ayudarnos a resolver el problema.

Se nos proporcionó 2 datasets: 

- application_record.csv: que contiene los datos de las solicitudes de tarjetas de crédito

- credit_record.csv: que contiene la información histórica del comportamiento de pagos


## Diccionario de datos

Descripción de los datasets

***application_record***

| Nombre | Descripción | Observaciones | 
|---|---|---|
| ID | Número de Cliente ||
| CODE_GENDER| Genero ||
| FLAG_OWN_CAR | Posee automovil propio? ||
| FLAG_OWN_REALTY | Es propietario? ||
| CNT_CHILDREN | Cantidad de Hijos || 
| AMT_INCOME_TOTAL | Ingreso Anual (u$d) ||
| NAME_INCOME_TYPE |	Tipo de Ingreso	||
| NAME_EDUCATION_TYPE | Nivel Educativo ||
| NAME_FAMILY_STATUS | Estado Civil ||
| NAME_HOUSING_TYPE | Tipo de Vivienda ||
| DAYS_BIRTH | dias desde la fecha de nacimiento ||
| DAYS_EMPLOYED | dias desde la fecha de inicio laboral ||
| FLAG_MOBIL | Tiene Celular? ||
| FLAG_WORK_PHONE | Dejó Telefono Laboral?	||
| FLAG_PHONE | Dejó Telefono Particular? ||
| FLAG_EMAIL | Dejó su Email?	||
| OCCUPATION_TYPE | Actividad Laboral ||
| CNT_FAM_MEMBERS | Cantidad Integrantes de la familia	||

***credit_record***

| Nombre | Descripción | Observaciones | 
|---|---|---|
| ID | Número de Cliente ||
| MONTHS_BALANCE | Mes del registro | El mes al que pertenece el registro es contado hacia atrás, 0 es el mes actual, -1 el anterior y así sucesivamente.
| STATUS | Estado | 0: 1-29 dias deudor 1: 30-59 dias deudor 2: 60-89 dias deudor 3: 90-119 dias deudor 4: 120-149 dias deudor 5: más de 150 dias deudor C: canceló las deudas ese mes X: sin deudas ese mes.

***Variables generadas al procesar los datos***

| Nombre | Descripción | Observaciones | 
|---|---|---|
| AGE | Edad ||
| YEARS_EMPLOYED | Años en el empleo ||
| Approved | (Objetivo) El crédito debe o no ser aprobado ||

## Configuración de ambiente y carga de los datos

Seteamos las librerías a utilizar y cargamos los datasets en el ambiente de trabajo.

```{r, message=FALSE}
##################
# Load libraries #
##################
library(ggplot2)
library(dplyr)
library(sqldf)
library(corrplot)
library(rms)
library(Information)
library(grid)
library(ROCR)
library(DMwR)
```

Si los datasets no están en el directorio de trabajo los descargamos:

```{r}
######################
# Download datafiles #
######################

# Set the data directory 
# It will be a subdirectory 'data/' of the current directory
maindir <- getwd()
datadir <- paste(maindir, "data", sep="/")

applRecordURL <- "https://raw.githubusercontent.com/ngladkoff/ds-credit-card-approval/master/data/application_record.csv"
credRecordURL <- "https://raw.githubusercontent.com/ngladkoff/ds-credit-card-approval/master/data/credit_record.csv"

applRecordFile <- paste(datadir, "applRecord.csv", sep="/")
credRecordFile <- paste(datadir, "credRecord.csv", sep="/")

if (!dir.exists(datadir)) {
    print(paste("Creating data directory ", datadir))
    dir.create(datadir)
}

if (!file.exists(applRecordFile)) {
    print("Downloading Application Records")
    download.file(applRecordURL, applRecordFile, method="auto")
} else {
    print(paste("Data file", applRecordFile, "already exists"))
}

if (!file.exists(credRecordFile)) {
    print("Downloading Application Records")
    download.file(credRecordURL, credRecordFile, method="auto")
} else {
    print(paste("Data file", credRecordFile, "already exists"))
}

```

```{r}
#######################
# Load the dataframes #
#######################

dfApplications <- read.csv(applRecordFile)
dfCredits <- read.csv(credRecordFile)

```


# Análisis Exploratorio de Datos

## 1 - Exámen inicial de los datos

### 1.1 - Applications

#### 1.1.1 - Estructura

```{r}
str(dfApplications)
```

En la estructura observamos el tipo de cada variable, observando algunas que necesitan ser convertidas en categóricas:

- FLAG_MOBIL
- FLAG_WORK_PHONE
- FLAG_PHONE
- FLAG_EMAIL

Se observa también algunas variables categóricas con muchas categorías, algo a tener en cuenta pues el tipo de problema puede resolverse utilizando una regresión logística, y este tipo de modelo pierde capacidad de predicción ante este tipo de variables.

Por último, nos llama la atención la variable DAYS_EMPLOYED que tiene valores negativos y positivos, algunos muy grandes (en el rango de los 1000 años)


#### 1.1.2 - Conversión variables categóricas

```{r}
dfApplications$FLAG_MOBIL <- factor(dfApplications$FLAG_MOBIL, ordered=FALSE)
dfApplications$FLAG_WORK_PHONE <- factor(dfApplications$FLAG_WORK_PHONE, ordered=FALSE)
dfApplications$FLAG_PHONE <- factor(dfApplications$FLAG_PHONE, ordered=FALSE)
dfApplications$FLAG_EMAIL <- factor(dfApplications$FLAG_EMAIL, ordered=FALSE)

```

#### 1.1.3 - Summary
```{r}
summary(dfApplications)
```

Se vuelve a observar alguna anormalidad en la variable DAYS_EMPLOYED que deberá ser analizada.

Se observa que la variable FLAG_MOBIL solo tiene una categoría, por lo que ya se puede descartar por no aportar valor al modelo.

La variable OCCUPATION_TYPE además de tener muchas categorías, como ya se había notado anteriormente, parece tener datos incompletos. Deberá ser analizado.

Respecto a la cantidad de hijos y el ingreso total vamos a tener que evaluar la distribución, los máximos y mínimos están muy lejos del promedio y la mediana.

#### 1.1.4 - Busqueda de IDs duplicados

Para asegurarnos que ambos datasets se puedan juntar una vez procesados debemos asegurarnos no tener IDs duplicados en el dataset de Applications.

```{r}
dfAppIds <- data.frame(table(dfApplications$ID))
cUniAppIds <- dim(dfApplications[unique(dfApplications$ID),])[1]
cDupAppIds <- dim(dfApplications[duplicated(dfApplications$ID),])[1]
cDupAppRecord <- dim(dfApplications[duplicated(dfApplications),])[1]
dfDupAppIds <- dfApplications[duplicated(dfApplications$ID),]
cAppIds <- dim(dfApplications)[1]

print(paste("IDs unicos:", cUniAppIds))
print(paste("IDs duplicados:", cDupAppIds))
print(paste("Records duplicados: ", cDupAppRecord))
print(paste("Total:", cAppIds))
print(paste("Duplicados: %", (round((cDupAppIds*100/cAppIds), digits=2))))

```

Observamos que tenemos 47 IDs duplicados, pero "Records duplicados" nos está marcando que contienen distintos datos, no es una misma solicitud cargada 2 veces sino que son 2 solicitudes con el mismo ID.

Por el bajo porcentaje que representan se decide eliminar del análisis estos registros duplicados.

```{r}
dfDupAppIds2 <- data.frame(dfDupAppIds$ID)
dfDupIds <- sqldf("SELECT distinct ID FROM dfApplications WHERE ID in dfDupAppIds2")
dfApplicationsCleaned <- sqldf("SELECT * FROM dfApplications WHERE ID NOT in dfDupAppIds2")
cNewTotal <- dim(dfApplicationsCleaned)[1]
print(paste("Cantidad Anterior - Cantidad Nueva: ",cAppIds - cNewTotal))
```

Verificamos que la cantidad nueva tiene 94 registros menos (47 duplicados x 2).


### 1.2 - Credits

#### 1.2.1 - Estructura

```{r}
str(dfCredits)
```

Aparentemente cada ID de solicitud se crean varios registros, uno por cada mes, con el estado de la deuda en dicho mes.

Se imprimen los primeros y ultimos registros para validar:
```{r}
head(dfCredits)
tail(dfCredits)
```

Como conslusión, vamos a necesitar reducir estos datos a un solo registro por ID de aplicación para poder fittiar nuestro modelo.


#### 1.2.2 - Summary

```{r}
summary(dfCredits)
```

No se observan números fuera de rango dentro de la variable MONTHS_BALANCE.

Para analizar correctamente la variable STATUS vamos a necesitar reducir los registros a uno por ID previamente.


## 2 - Reducción dataset Credits

### 2.1 - Identificar IDs únicos
```{r}
dfCredIds <- data.frame(table(dfCredits$ID))
```


#### 2.1.1 - Estructura
```{r}
str(dfCredIds)
```

El dataset Credits cuenta con 45985 IDs únicos, es decir que del dataset de Applications de poco más de 438000 registros solo tenemos información de algunos.

#### 2.1.2 - Summary
```{r}
summary(dfCredIds)
```


### 2.2 - Reducir registros

Se decidió que vamos a tomar el estado del último més del que tenemos información. 

Para esto recuperamos primero cual es ese último mes:
```{r}

dfCreditsLastMonth <- sqldf("SELECT ID, MAX(MONTHS_BALANCE) as LAST FROM dfCredits GROUP BY ID order by LAST")
str(dfCreditsLastMonth)

```

Verificamos que la cantidad de registros coincide con el análisis de IDs únicos. 

Continuamos agregando el estádo del crédito en ese último mes.
```{r}
dfCreditsReduced <- sqldf("SELECT t1.ID, t1.LAST, t2.STATUS FROM dfCreditsLastMonth t1 JOIN dfCredits t2 ON t1.ID = t2.ID and t1.LAST = t2.MONTHS_BALANCE")
summary(dfCreditsReduced)
```

Definimos nuestra variable objetivo: Approve. Para esto teniendo en cuenta el STATUS en el último mes que se tiene registro, asumimos que si no quedó con deuda (estados C, X y 0) debería ser aprobada esa solicitud y si quedó en alguno de los otros estados entonces no.
```{r}
dfCreditsReduced$Approve <- ifelse(dfCreditsReduced$STATUS == 'C' | dfCreditsReduced$STATUS == 'X' | dfCreditsReduced$STATUS == '0', 1, 0)
dfCreditsReduced$Approve <- factor(dfCreditsReduced$Approve, ordered = FALSE)
summary(dfCreditsReduced)
```

Se observa que la cantidad de créditos "malos" es de aproximadamente el 1%, que no es un porcentaje razonable de incobrabilidad, que según lo que hemos investigado suele ser lijeramente superior al 3%. 


## 3 - Unificar los datasets

### 3.1 - Unificar
```{r}
dfCreditCard <- merge(dfApplicationsCleaned, dfCreditsReduced, by="ID")
```

### 3.2 - Estructura
```{r}
str(dfCreditCard)
```

### 3.3 - Summary
```{r}
summary(dfCreditCard)
```


### 3.4 - Conclusiones de la unificación

Luego de unir ambos datasets observamos que la cantidad de registros de clientes que poseen información histórica ha disminuido. 

Esto se debe a que no todas las solicitudes de tarjeta de crédito tienen asociado un historial crediticio registrado. 

Para los fines de este análisis, aceptaremos cómo válida esta reducción en el set de datos.
 
```{r}
print(paste("Registros en el historial:", dim(dfCreditsReduced)[1]))
print(paste("Solicitudes de tarjetas de crédito con registros en el historial:", dim(dfCreditCard)[1]))
```



## 4 - Análisis de variables sobre dataset unificado

### 4.1 - Análisis de variables númericas

#### 4.1.1. - Variable: CNT_CHILDREN

##### CNT_CHILDREN

En relación a la variable *CNT_CHILDREN* observaremos la distribución de la cantidad total de hijos en cada barra del siguiente gráfico:

```{r}
ggplot(dfCreditCard) + 
  geom_histogram(
    aes(x=CNT_CHILDREN), 
    fill="steel blue",
    col= "yellow",
    alpha= .6,
    binwidth = 1) + 
  labs(title="Histograma: Cantidad de hijos en Solicitudes", x="Cantidad Hijos", y="Cantidad Solicitudes")
```

Se observa una marcada concentración respeto de la cantidad de hijos cuando dicho valor es menor o igual a 2.

```{r}
summary(dfCreditCard$CNT_CHILDREN)
```

Se observa en el summary la presencia de valores cercanos a 20, pero como puede observarse en el gráfico anterior son outliers, no hay concentración en esas cantidades.

##### CNT_CHILDREN vs APPROVE

Vamos a utilizar el gráfico BoxPlot para tratar de entender como se relacionan la variable CNT_CHILDREN y nuestra variable Objetivo.

```{r}
ggplot(dfCreditCard) + 
  geom_boxplot(aes(x=Approve, y=CNT_CHILDREN), outlier.color = "red", col="yellow", fill="steel blue", alpha=0.6) +
  labs(title="BoxPlot: Calidad Crediticia según Cantidad de Hijos", x="Credito Malo (0) o Bueno (1)", y="Cantidad de Hijos")
```

Observamos que la cantidad de casos aprobados en comparación de los que no, se mantienen en valores similares. Esto sucede hasta aproximadamente los 5 hijos. Luego de ese valor, aumenta la cantidad de casos con falta de pago en su historial crediticio.

Representando los datos de una manera diferente, podemos observar que la inferencia realizada anteriormente es consistente.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=CNT_CHILDREN, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según cantidad de hijos", x="Cantidad de Hijos", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```


Los casos donde la cantidad de hijos sea mayor a 5 supone una falta de pago de acuerdo al criterio mencionado previamente.

Debemos mencionar que esta suposición tiene lógica desde el punto de vista del negocio, por tratarse de outliers, poco representados, podríamos estar sesgando el resultado. Debemos ser cuidadosos, pero podría ser un posible predictor.


#### 4.1.2. - Variable: AMT_INCOME_TOTAL

##### AMT_INCOME_TOTAL

En relación a la variable *AMT_INCOME_TOTAL* observaremos su distribuciónen el siguiente gráfico:

```{r}
ggplot(dfCreditCard) + 
  geom_histogram(
    aes(x=AMT_INCOME_TOTAL), 
    fill="steel blue",
    col= "yellow",
    alpha= .6, bins=10) + 
  labs(title="Histograma: Ingresos", x="Ingreso anual (u$d)", y="Cantidad Solicitudes")
```

Se observa una marcada concentración de solicitudes en un rango medio de ingresos anuales. si bien se observa la presencia de algunas solicitudes con ingresos muy superiores.

```{r}
summary(dfCreditCard$AMT_INCOME_TOTAL)
```

Dentro del rango de los 120000 y los 225000 dolares anuales de ingreso se concentra el 50% de las solicitudes de tarjeta de crédito. Vemos la presencia de valores muy inferiores y muy superiores.


##### AMT_INCOME_TOTAL vs APPROVE

Vamos a utilizar el gráfico BoxPlot para tratar de entender como se relacionan la variable AMT_INCOME_TOTAL y nuestra variable Objetivo.

```{r}
ggplot(dfCreditCard) + 
  geom_boxplot(aes(x=Approve, y=AMT_INCOME_TOTAL), outlier.color = "red", col="yellow", fill="steel blue", alpha=0.6) +
  labs(title="BoxPlot: Calidad Crediticia según Ingresos Anuales", x="Credito Malo (0) o Bueno (1)", y="Ingresos (u$d)")
```

No observamos diferencias significativas en este gráfico. Vamos a intentar representarlo de manera diferente.

```{r}
ggplot(dfCreditCard) +
  geom_histogram(aes(x=AMT_INCOME_TOTAL, fill=Approve), position="fill", alpha=.5, bins=10) +
  labs(title="Creditos Buenos vs Creditos Malos según Ingresos Anuales", x="Ingresos (u$d)", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```

El comportamiento que observamos en el gráfico para las solicitudes con mayores ingresos parece ser ruido por la baja cantidad de datos con los que esa categoría está representada en la muestra. 

No parece existir una marcada relación entre los ingresos y la calidad crediticia.


#### 4.1.3. - Variable: DAYS_BIRTH

##### DAYS_BIRTH

```{r}
summary(dfCreditCard$DAYS_BIRTH)
```

Como se observa, está expresado en días y en negativo, vamos a convertirlo a una escala a la que estamos más acostumbrados a ver, que es expresar la edad en años.

```{r}
dfCreditCard$AGE <- (dfCreditCard$DAYS_BIRTH * -1) %/% 365 
summary(dfCreditCard$AGE)
```

Expresado de esta manera podemos observar que los valores son razonables. 

Observaremos la distribución en el siguiente gráfico:

```{r}
ggplot(dfCreditCard) + 
  geom_histogram(
    aes(x=AGE), 
    fill="steel blue",
    col= "yellow",
    alpha= .6, bins=10) + 
  labs(title="Histograma: Edades", x="Años", y="Cantidad Solicitudes")
```

Observamos una distribución con cierta semejanza a una campana de Gauss (Normal). 
 

##### AGE vs APPROVE

Vamos a utilizar el gráfico BoxPlot para tratar de entender como se relacionan la variable AGE y nuestra variable Objetivo.

```{r}
ggplot(dfCreditCard) + 
  geom_boxplot(aes(x=Approve, y=AGE), outlier.color = "red", col="yellow", fill="steel blue", alpha=0.6) +
  labs(title="BoxPlot: Calidad Crediticia según Edad", x="Credito Malo (0) o Bueno (1)", y="Años")
```

No observamos diferencias significativas en este gráfico. Vamos a intentar representarlo de manera diferente.

```{r}
ggplot(dfCreditCard) +
  geom_histogram(aes(x=AGE, fill=Approve), position="fill", alpha=.5, binwidth = 10) +
  labs(title="Creditos Buenos vs Creditos Malos según Edades", x="Años", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```

Parece existir una ligera tendencia a que los créditos mejoren a medida que aumenta la edad. Podría ser un posible predictor.


#### 4.1.4. - Variable: DAYS_EMPLOYED

##### DAYS_EMPLOYED

```{r}
summary(dfCreditCard$DAYS_EMPLOYED)
```

Como se observa, está expresado en días y en negativo, vamos a convertirlo a una escala a la que estamos más acostumbrados a ver, que es expresarlo en años. Se observan también valores positivos, que se les va a tener que dar un tratamiento.

```{r}
dfCreditCard$YEARS_EMPLOYED <- (dfCreditCard$DAYS_EMPLOYED * -1) %/% 365 
summary(dfCreditCard$YEARS_EMPLOYED)
```

Expresado de esta manera podemos observar edades negativas. 

Buscamos estos valores:

```{r}
dfNegatives <- filter(dfCreditCard, YEARS_EMPLOYED < 0)
str(dfNegatives)
```

Observamos un número importante de registros con este dato inválido. Como no podemos consultar a negocio que significan esos valores suponemos que "antigüedad laboral desconocida", los vamos a reemplazar por la mediana que es más representativa de la antigüedad que el promedio, justamente por la presencia de estos valores.

```{r}
dfCreditCard$YEARS_EMPLOYED[dfCreditCard$YEARS_EMPLOYED < 0] <- median(dfCreditCard$YEARS_EMPLOYED)

summary(dfCreditCard$YEARS_EMPLOYED)
```

Ahora los valores parecen razonables.

Observaremos la distribución en el siguiente gráfico:

```{r}
ggplot(dfCreditCard) + 
  geom_histogram(
    aes(x=YEARS_EMPLOYED), 
    fill="steel blue",
    col= "yellow",
    alpha= .6, bins=10) + 
  labs(title="Histograma: Antigüedad Laboral", x="Años", y="Cantidad Solicitudes")
```

##### YEARS_EMPLOYED vs APPROVE

Vamos a utilizar el gráfico BoxPlot para tratar de entender como se relacionan la variable YEARS_EMPLOYED y nuestra variable Objetivo.

```{r}
ggplot(dfCreditCard) + 
  geom_boxplot(aes(x=Approve, y=YEARS_EMPLOYED), outlier.color = "red", col="yellow", fill="steel blue", alpha=0.6) +
  labs(title="BoxPlot: Calidad Crediticia según Antigüedad Laboral", x="Credito Malo (0) o Bueno (1)", y="Años")
```

Se observan algunas pequeñas diferencias en este gráfico. Vamos a intentar representarlo de manera diferente.

```{r}
ggplot(dfCreditCard) +
  geom_histogram(aes(x=YEARS_EMPLOYED, fill=Approve), position="fill", alpha=.5, binwidth = 10) +
  labs(title="Creditos Buenos vs Creditos Malos según Antigüedad Laboral", x="Años", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```

La pequeña diferencia notada en el gráfico anterior desaparece en este gráfico, donde no parece haber una clara relación entre la calidad crediticia y la antigüedad laboral.


#### 4.1.5. - Variable: CNT_FAM_MEMBERS

##### CNT_FAM_MEMBERS

En relación a la variable *CNT_FAM_MEMBERS* observaremos la distribución de la cantidad total de integrantes de la familia, en cada barra del siguiente gráfico:

```{r}
ggplot(dfCreditCard) + 
  geom_histogram(
    aes(x=CNT_FAM_MEMBERS), 
    fill="steel blue",
    col= "yellow",
    alpha= .6,
    binwidth = 1) + 
  labs(title="Histograma: Cantidad de Integrantes Familiares en Solicitudes", x="Cantidad Integrantes", y="Cantidad Solicitudes")
```

Como era de esperarse se observa una distribución similar a la cantidad de hijos, son variables claramente relacionadas.

##### CNT_FAM_MEMBERS vs APPROVE

Es de esperarse que la relación entre estas dos variables sea similar a lo ya evaluado con cantidad de hijos, se utiliza el gráfico de barras para convalidarlo.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=CNT_FAM_MEMBERS, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según cantidad de miembros familiares", x="Cantidad de integrantes", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```


Para su elección o no como predictor deberíamos evaluar si vamos o no a incluir Cantidad de Hijos, porque solo una de las dos variables sería el predictor por estar correlacionadas entre ellas.

#### 4.1.6. - Variable: LAST

Es una variable que creamos nosotros para expresar el último período del cual tenemos datos, sirvió de variable intermedia para calcular la situación crediticia. No sirve como predictor.


### 4.2 - Correlación de variables numéricas

Mediante un gráfico de correlación de las variables numéricas vamos a analizar como se relacionan entre ellas.

```{r}
dfcor <- select_if(dfCreditCard, is.numeric)
dfcor <- select(dfcor, -ID, -LAST, -DAYS_EMPLOYED, -DAYS_BIRTH)
cm <- cor(dfcor)
corrplot(cm, method = "number", type = "upper")
```


Observamos en el gráfico que Cantidad de Hijos y Cantidad de Miembros Familiares están muy relaionados, nos parece más amplio el concepto de Miembros Familiares para seleccionarlo como predictor.

No observamos correlaciones significativas entre el resto de las variables.


### 4.3 - Análisis de variables categóricas

#### 4.3.1 - Variable: CODE_GENDER

##### CODE_GENDER

Para conocere la distribución de la muestra graficamos con barras las 2 categorías:

```{r}
ggplot(dfCreditCard) + 
  geom_bar(
    aes(x=CODE_GENDER), 
    stat="count",
    fill="steel blue",
    col= "yellow",
    alpha= .6) + 
    labs(title="Barras: Distribución por Genero", x="Genero", y="Cantidad Solicitudes") +
    coord_flip()
```

Se observa que la muestra contiene aproximadamente dos tercios de mujeres. Evaluar si es algo que podría sesgar el modelo.


##### CODE_GENDER vs APPROVE

Verificamos si podría existir alguna relación entre ambas variables mediante un gráfico de barras apiladas.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=CODE_GENDER, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según genero", x="Genero", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```

A pesar que la muestra contenía mayor cantidad de solicitudes del sexo femenino, la distribución respecto a la calidad crediticia es similar a las solicitudes presentadas por el sexo masculino. No parece existir una relación entre el genero y la calidad crediticia.


#### 4.3.2 - Variable: FLAG_OWN_CAR

##### FLAG_OWN_CAR

Para conocere la distribución de la muestra graficamos con barras las 2 categorías:

```{r}
ggplot(dfCreditCard) + 
  geom_bar(
    aes(x=FLAG_OWN_CAR), 
    stat="count",
    fill="steel blue",
    col= "yellow",
    alpha= .6) + 
    labs(title="Barras: Distribución por Auto Propio", x="Auto propio", y="Cantidad Solicitudes") +
    coord_flip()
```


##### FLAG_OWN_CAR vs APPROVE

Verificamos si podría existir alguna relación entre ambas variables mediante un gráfico de barras apiladas.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=FLAG_OWN_CAR, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según si tienen o no Auto Propio", x="No / SI", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```

No parece existir una relación entre el Auto Propio y la calidad crediticia.


#### 4.3.3 - Variable: FLAG_OWN_REALTY

##### FLAG_OWN_REALTY

Para conocere la distribución de la muestra graficamos con barras las 2 categorías:

```{r}
ggplot(dfCreditCard) + 
  geom_bar(
    aes(x=FLAG_OWN_REALTY), 
    stat="count",
    fill="steel blue",
    col= "yellow",
    alpha= .6) + 
    labs(title="Barras: Distribución por Casa Propia", x="Casa propia", y="Cantidad Solicitudes") +
    coord_flip()
```


##### FLAG_OWN_REALTY vs APPROVE

Verificamos si podría existir alguna relación entre ambas variables mediante un gráfico de barras apiladas.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=FLAG_OWN_REALTY, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según si tienen o no Casa Propia", x="NO / SI", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```

No parece existir una relación entre el Casa Propia y la calidad crediticia.


#### 4.3.4 - Variable: FLAG_MOBIL

##### FLAG_MOBIL

Para conocere la distribución de la muestra graficamos con barras las 2 categorías:

```{r}
ggplot(dfCreditCard) + 
  geom_bar(
    aes(x=FLAG_MOBIL), 
    stat="count",
    fill="steel blue",
    col= "yellow",
    alpha= .6) + 
    labs(title="Barras: Distribución por Tenencia Celular", x="Celular", y="Cantidad Solicitudes") +
    coord_flip()
```

Se observa que todos las solicitudes tienen Teléfono Celular, no nos sirve para la predicción.


#### 4.3.5 - Variable: FLAG_WORK_PHONE

##### FLAG_WORK_PHONE

Para conocere la distribución de la muestra graficamos con barras las 2 categorías:

```{r}
ggplot(dfCreditCard) + 
  geom_bar(
    aes(x=FLAG_WORK_PHONE), 
    stat="count",
    fill="steel blue",
    col= "yellow",
    alpha= .6) + 
    labs(title="Barras: Distribución por Telefono Laboral", x="Telefono Laboral", y="Cantidad Solicitudes") +
    coord_flip()
```


##### FLAG_WORK_PHONE vs APPROVE

Verificamos si podría existir alguna relación entre ambas variables mediante un gráfico de barras apiladas.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=FLAG_WORK_PHONE, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según si dejaron o no el teléfono laboral", x="NO / SI", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```

Parece existir una ligera diferencia, podría ser un posible predictor.


#### 4.3.6 - Variable: FLAG_PHONE

##### FLAG_PHONE

Para conocere la distribución de la muestra graficamos con barras las 2 categorías:

```{r}
ggplot(dfCreditCard) + 
  geom_bar(
    aes(x=FLAG_PHONE), 
    stat="count",
    fill="steel blue",
    col= "yellow",
    alpha= .6) + 
    labs(title="Barras: Distribución por Telefono Personal", x="Telefono Personal", y="Cantidad Solicitudes") +
    coord_flip()
```


##### FLAG_PHONE vs APPROVE

Verificamos si podría existir alguna relación entre ambas variables mediante un gráfico de barras apiladas.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=FLAG_PHONE, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según si dejaron o no el teléfono personal", x="NO / SI", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```

No parece existir una relación entre el teléfono personal y la calidad crediticia.


#### 4.3.7 - Variable: FLAG_EMAIL

##### FLAG_EMAIL

Para conocere la distribución de la muestra graficamos con barras las 2 categorías:

```{r}
ggplot(dfCreditCard) + 
  geom_bar(
    aes(x=FLAG_EMAIL), 
    stat="count",
    fill="steel blue",
    col= "yellow",
    alpha= .6) + 
    labs(title="Barras: Distribución por Email", x="Email", y="Cantidad Solicitudes") +
    coord_flip()
```


##### FLAG_EMAIL vs APPROVE

Verificamos si podría existir alguna relación entre ambas variables mediante un gráfico de barras apiladas.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=FLAG_EMAIL, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según si dejaron o no el email", x="NO / SI", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```

Parece existir una muy ligera diferencia, podría ser un posible predictor.


#### 4.3.8 - Variable: NAME_INCOME_TYPE

##### NAME_INCOME_TYPE

Para conocere la distribución de la muestra graficamos con barras diferentes categorías:

```{r}
catIncomeType <- table(dfCreditCard$NAME_INCOME_TYPE)
dfCatIncomeType <- as.data.frame(catIncomeType)
names(dfCatIncomeType) <- c("Categoria","Cantidad")

# Ordenamos
dfCatIncomeType <- transform(dfCatIncomeType, Categoria=reorder(Categoria, Cantidad))

ggplot(dfCatIncomeType) + 
  geom_bar(
    aes(x=Categoria, y=Cantidad), 
    stat="identity",
    fill="steel blue",
    col= "yellow",
    alpha= .6) + 
    labs(title="Barras: Distribución por Tipo de Ingreso", x="Categoría", y="Cantidad Solicitudes") +
    coord_flip()
```


##### NAME_INCOME_TYPE vs APPROVE

Verificamos si podría existir alguna relación entre ambas variables mediante un gráfico de barras apiladas.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=NAME_INCOME_TYPE, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según Tipo de Ingreso", x="Categoría", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```

Podría existir alguna relación entre las variables, aunque la diferencia observada en la categoría estudiantes debe ser tenida en cuenta en el contexto observado en el gráfico anterior, donde vemos que las solicitudes de estudiantes son insignificantes en la muestra.


#### 4.3.9 - Variable: NAME_EDUCATION_TYPE

##### NAME_EDUCATION_TYPE

Para conocere la distribución de la muestra graficamos con barras diferentes categorías:

```{r}
catIncomeType <- table(dfCreditCard$NAME_EDUCATION_TYPE)
dfCatIncomeType <- as.data.frame(catIncomeType)
names(dfCatIncomeType) <- c("Categoria","Cantidad")

# Ordenamos
dfCatIncomeType <- transform(dfCatIncomeType, Categoria=reorder(Categoria, Cantidad))

ggplot(dfCatIncomeType) + 
  geom_bar(
    aes(x=Categoria, y=Cantidad), 
    stat="identity",
    fill="steel blue",
    col= "yellow",
    alpha= .6) + 
    labs(title="Barras: Distribución por Nivel de Educación", x="Categoría", y="Cantidad Solicitudes") +
    coord_flip()
```


##### NAME_EDUCATION_TYPE vs APPROVE

Verificamos si podría existir alguna relación entre ambas variables mediante un gráfico de barras apiladas.

```{r}
# print(levels(dfCreditCard$NAME_EDUCATION_TYPE))
```


```{r}
# dfCreditCard$NAME_EDUCATION_TYPE <- factor(dfCreditCard$NAME_EDUCATION_TYPE, levels = c("Lower secondary","Secondary / secondary special","Incomplete higher", "Higher education", "Academic degree"), ordered = TRUE)

ggplot(dfCreditCard) +
  geom_bar(aes(x=NAME_EDUCATION_TYPE, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según Nivel de Educación", x="Categoría", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green"))
```


En esta variable visualizamos una relación mas marcada entre el nivel de educación y la calidad crediticia. Podría ser un posible predictor.


#### 4.3.10 - Variable: NAME_FAMILY_STATUS

##### NAME_FAMILY_STATUS

Para conocere la distribución de la muestra graficamos con barras diferentes categorías:

```{r}
catIncomeType <- table(dfCreditCard$NAME_FAMILY_STATUS)
dfCatIncomeType <- as.data.frame(catIncomeType)
names(dfCatIncomeType) <- c("Categoria","Cantidad")

# Ordenamos
dfCatIncomeType <- transform(dfCatIncomeType, Categoria=reorder(Categoria, Cantidad))

ggplot(dfCatIncomeType) + 
  geom_bar(
    aes(x=Categoria, y=Cantidad), 
    stat="identity",
    fill="steel blue",
    col= "yellow",
    alpha= .6) + 
    labs(title="Barras: Distribución por Estado Civil", x="Categoría", y="Cantidad Solicitudes") +
    coord_flip()
```


##### NAME_FAMILY_STATUS vs APPROVE

Verificamos si podría existir alguna relación entre ambas variables mediante un gráfico de barras apiladas.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=NAME_FAMILY_STATUS, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según Estado Civil", x="Categoría", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green")) +
    coord_flip()
```


Se visualiza una ligera relación entre las variables. Podría ser un posible predictor.


#### 4.3.11 - Variable: NAME_HOUSING_TYPE

##### NAME_HOUSING_TYPE

Para conocere la distribución de la muestra graficamos con barras diferentes categorías:

```{r}
catIncomeType <- table(dfCreditCard$NAME_HOUSING_TYPE)
dfCatIncomeType <- as.data.frame(catIncomeType)
names(dfCatIncomeType) <- c("Categoria","Cantidad")

# Ordenamos
dfCatIncomeType <- transform(dfCatIncomeType, Categoria=reorder(Categoria, Cantidad))

ggplot(dfCatIncomeType) + 
  geom_bar(
    aes(x=Categoria, y=Cantidad), 
    stat="identity",
    fill="steel blue",
    col= "yellow",
    alpha= .6) + 
    labs(title="Barras: Distribución por Tipo de Vivienda", x="Categoría", y="Cantidad Solicitudes") +
    coord_flip()
```


##### NAME_HOUSING_TYPE vs APPROVE

Verificamos si podría existir alguna relación entre ambas variables mediante un gráfico de barras apiladas.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=NAME_HOUSING_TYPE, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según Tipo Vivienda", x="Categoría", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green")) +
    coord_flip()
```


Se visualiza una relación entre las variables. Podría ser un posible predictor.


#### 4.3.12 - Variable: OCCUPATION_TYPE

##### OCCUPATION_TYPE

Como se observó en el summary, la categoría tiene datos incompletos.
```{r}
summary(dfCreditCard$OCCUPATION_TYPE)
```

No podemos consultar a negocio si son solicitudes incompletas o representa la categoría "Otros". A los fines del ejercicio se decide etiquetarlos como "Otros".

```{r}
levels(dfCreditCard$OCCUPATION_TYPE)[levels(dfCreditCard$OCCUPATION_TYPE) == ""] <- "Other"
summary(dfCreditCard$OCCUPATION_TYPE)
```

Para conocere la distribución de la muestra graficamos con barras diferentes categorías:

```{r}
catIncomeType <- table(dfCreditCard$OCCUPATION_TYPE)
dfCatIncomeType <- as.data.frame(catIncomeType)
names(dfCatIncomeType) <- c("Categoria","Cantidad")

# Ordenamos
dfCatIncomeType <- transform(dfCatIncomeType, Categoria=reorder(Categoria, Cantidad))

ggplot(dfCatIncomeType) + 
  geom_bar(
    aes(x=Categoria, y=Cantidad), 
    stat="identity",
    fill="steel blue",
    col= "yellow",
    alpha= .6) + 
    labs(title="Barras: Distribución por Actividad Laboral", x="Categoría", y="Cantidad Solicitudes") +
    coord_flip()
```

En esta variable existen muchas categorías, y según la bibliografía la regresión logística tiene problemas con variables categóricas con muchas categorías. Revisar si afecta o no al modelo.

##### OCCUPATION_TYPE vs APPROVE

Verificamos si podría existir alguna relación entre ambas variables mediante un gráfico de barras apiladas.

```{r}
ggplot(dfCreditCard) +
  geom_bar(aes(x=OCCUPATION_TYPE, fill=Approve), position="fill", alpha=.5) +
  labs(title="Creditos Buenos vs Creditos Malos según Actividad Laboral", x="Categoría", y="%") +
  scale_fill_manual(values= c("0"= "red", "1"="green")) +
    coord_flip()
```

Se visualiza una relación entre las variables. Podría ser un posible predictor.


# Construcción del Modelo Predictivo

## 1 - Preparar los datasets de Training y de Testing

Se observa en la variable objetivo que la muestra está muy desbalanceada. Se va a hacer un SMOTE para mejorar el balance.

```{r}
dfCreditCardSMOTE <- SMOTE(Approve ~ ., dfCreditCard, perc.over = 500, k=5, perc.under=150)
str(dfCreditCardSMOTE)
summary(dfCreditCardSMOTE)
```


Dividimos el set de datos en un 80% para entrenamiento y un 20% para prueba.

```{r}
muestra <- floor(nrow(dfCreditCardSMOTE) * 0.8)
trainingIndex <- sample(nrow(dfCreditCardSMOTE), muestra, replace=FALSE)
testIndex <- seq_len(nrow(dfCreditCardSMOTE))[!(seq_len(nrow(dfCreditCardSMOTE)) %in% trainingIndex)]

dfTrainLR <- dfCreditCardSMOTE[trainingIndex,]
dfTestLR <- dfCreditCardSMOTE[testIndex,]
```


## 2 - Fittiamos el modelo de Regresión Logística

Como el problema planteado es de clasificación binaria, es decir intentamos predecir una variable dicotómica, el modelo a probar primero es la Regresión Logística.

### 2.1 - Seleccionamos Predictores en base al análisis

Como primera aproximación vamos a utilizar como predictores todas las variables que detectamos podrían tener alguna relación con la variable objetivo.

```{r}
objetivo <- "Approve"
predictores <- c("CODE_GENDER", "AMT_INCOME_TOTAL", "AGE", "CNT_FAM_MEMBERS", "FLAG_WORK_PHONE", "FLAG_EMAIL", "NAME_EDUCATION_TYPE", "NAME_FAMILY_STATUS", "NAME_HOUSING_TYPE", "OCCUPATION_TYPE", "YEARS_EMPLOYED")
print(predictores)
```

### 2.2 - Creamos la formula del modelo

```{r}
formula <- paste(objetivo, paste(predictores, collapse = " + "), sep=" ~ ")
print(formula)
```

### 2.3 - Entrenamos el modelo

```{r}
modeloLR <- glm(formula, data=dfTrainLR, family=binomial(link="logit"))
```

### 2.4 - Visualizamos el summary del modelo

```{r}
summary(modeloLR)
```

Del análisis de coeficientes AGE, CNT_FAM_MEMBERS y NAME_FAMILY_STATUS no parecen ser confiables.

### 2.5 - Verificamos los  variance inflation factors (VIF)

Verificamos que tan afectados están los coeficientes por culpa de la regresión.
La regla es:
- < A 5 BIEN
- 5 A 10 POLEMICO
- > A 10 NO SIRVE 

```{r}
vif(modeloLR)
```

Las variables NAME_EDUCATION_TYPE y NAME_HOUSING_TYPE están muy afectadas por la regresión.


### 2.6 - Probamos re-entrenar el modelo

Vamos a entrenar un nuevo modelo sin las variables 

```{r}
predictores <- c("CODE_GENDER", "AMT_INCOME_TOTAL", "FLAG_WORK_PHONE", "FLAG_EMAIL", "NAME_FAMILY_STATUS", "NAME_HOUSING_TYPE", "OCCUPATION_TYPE", "YEARS_EMPLOYED")
formula <- paste(objetivo, paste(predictores, collapse = " + "), sep=" ~ ")
modeloLR <- glm(formula, data=dfTrainLR, family=binomial(link="logit"))
```

#### Summary
```{r}
summary(modeloLR)
```


#### VIF
```{r}
vif(modeloLR)
```

# Evaluación del Modelo

## 1 - Plotear distribución de predicciones

```{r}
dfTrainLR$pred <- predict(modeloLR, newdata= dfTrainLR, type="response")
dfTestLR$pred <- predict(modeloLR, newdata= dfTestLR, type="response")

ggplot(dfTrainLR) + 
  geom_density(aes(x=pred, colour=as.factor(Approve), linetype=as.factor(Approve))) +
  xlab("Predicción") + 
  ylab("Densidad") +
  theme_bw()
```

Lo que se observa en el gráfico es que el modelo no sirve, las clases deberían estar bien separadas para poder setear un **threshold**.

## 2 - Matriz de confusión

Definimos la función:
```{r}
nplot <- function(plist) {
  n <- length(plist)
  grid.newpage()
  pushViewport(viewport(layout=grid.layout(n,1)))
  vplayout=function(x,y) { viewport(layout.pos.row=x, layout.pos.col=y) }
  for (i in 1:n) {
    print(plist[[i]], vp=vplayout(i,1))
  }
}

```


```{r}
predObj <-prediction(dfTrainLR$pred, dfTrainLR$Approve)
precObj <- performance(predObj, measure = "prec")
recObj <- performance(predObj, measure = "rec")

precision <- (precObj@y.values)[[1]]
prec.x <- (precObj@x.values)[[1]]
recall <- (recObj@y.values)[[1]]

pnull <- (length(which(dfTrainLR$Approve == 1)) / length(which(dfTrainLR$Approve != 2)))
pnull

# Data for the plot
dfplot <- data.frame(threshold=prec.x, precision=precision, recall=recall)

p1 <- ggplot(dfplot, aes(x=threshold)) +
  geom_line(aes(y=precision/pnull)) +
  xlab("Umbral") +
  ylab("Precisión / P_0")

p2 <- ggplot(dfplot, aes(x=threshold)) +
  geom_line(aes(y=recall)) +
  xlab("Umbral") +
  ylab("Exhaustividad")

nplot(list(p1, p2))

```

Probamos con un umbral del 50% para despues ir ajustando.

```{r}
thresh <- 0.50
ctab.test <- table(prediccion=as.numeric(dfTestLR$pred > thresh), datos=dfTestLR$Approve)
ctab.test

precision <- ctab.test[2,2]/sum(ctab.test[2,])
paste("Precision:", precision)

recall <- ctab.test[2,2]/sum(ctab.test[,2])
paste("Recall:",recall)

enrich <- precision / pnull
paste("Enrich:",enrich)

```


## 3 - Curva ROC 

```{r}
sensObj <- performance(predObj, measure="sens")
specObj <- performance(predObj, measure="spec")
sensitivity <- (sensObj@y.values)[[1]]
specificity <- (specObj@y.values)[[1]]

dfplot <- data.frame(specm1=1-specificity, sens=sensitivity)
fig <- ggplot(dfplot, aes(x=specm1, y=sens))
fig <- fig + geom_line(color="red", size=1.25)
fig <- fig + geom_abline(aes(slope=1, intercept=0))
fig <- fig + theme_bw()
fig <- fig + xlab("1 - Especificidad")
fig <- fig + ylab("Sensibilidad")
fig

```


## 4 - Ajustamos el Umbral del modelo

Probamos con 45%, 55%, 60% y 65%. El mejor balance para las necesidades de negocio es con el 60%. 

```{r}
thresh <- 0.60
ctab.test <- table(prediccion=as.numeric(dfTestLR$pred > thresh), datos=dfTestLR$Approve)
ctab.test

precision <- ctab.test[2,2]/sum(ctab.test[2,])
paste("Precision:", precision)

recall <- ctab.test[2,2]/sum(ctab.test[,2])
paste("Recall:",recall)

enrich <- precision / pnull
paste("Enrich:",enrich)

```



## ToDo

Cambiar objetivo
Revisar textos y graficos por el cambio de Approve
Ajustar las variables del modelo, ver predictores

Podríamos fittear 2 modelos con distintos predictores y comparar matriz confusión







# Análisis de Resultados



# Conclusiones



